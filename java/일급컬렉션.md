# 일급컬렉션

출처 : https://jojoldu.tistory.com/412

- 다른 멤버 변수 없이 하나의 컬렉션만을 포함하고 있는 클래스
- 컬렉션을 Wrapping 하면서 그 외 다른 멤버 변수가 없는 상태의 클래스 -> 컬렉션으로 사용
- 컬렉션은 그 자체로 포장되어 있으므로 컬렉션과 관련된 동작의 근거지가 마련됨


1. 비지니스에 종속된 자료구조

    - 특정 비지니스에 사용되는 컬렉션일 경우 비지니스에 특화된 검증 로직이 필요한 경우가 많다. 
        - ex) 로또 번호는 6개로 이루어져야 하며, 중복되어서는 안된다.
    - 모든 코드가 이러한 도메인을 알고 있지 않다.
    
    **-> 일급 컬렉션을 통해 해당 조건을 만족하도록 강제하는 컬렉션을 만들 수 있다.**

2. 불변성 보장 (목적 : side effect 최소화)
    - final 키워드는 불변을 만들어주는 것이 아닌, 재할당을 금지하는 키워드
        ```java
        final Map<String, Boolean> hm = new HashMap<>();

        map.put("1", true); //값을 추가해도 막을 수 없다.
        ```
    - 일급 컬렉션을 통해 불변성 보장 가능
        ```java
        public class Orders{

            private final List<Order> orders;

            //생성자를 통해 private 컬렉션을 생성하므로 외부에서 접근 불가 -> 값 변경, 추가 불가
            public Orders(List<Orders> orders){
                this.orders = orders;
            }

            public long getAmountSum(){
                return orders.stream().mapToLong(Order::getAmount).sum();
            }
        }
        ```

3. 상태와 행위를 한 곳에서 관리
    - 해당 컬렉션을 사용하는 비지니스 로직이 필요한 경우 서로 관계가 있음을 코드로 표현할 수 없다.
        - 똑같은 기능을 하는 메서드를 중복 생성할 수 있다. (다른 사람은 그 메서드가 있는 걸 모름)-> 로직이 변경될 경우 어떤 메서드를 변경해야하는지 지 알 수 없다.
        - 관리 포인트의 증가
    - oop에서는 클래스가 데이터에 대한 책임을 지게 하려고 내부에 메서드를 생성함으로서 자율적인 존재로 만드는데, 컬렉션같은 경우는 내부 조작을 할 수 없음
        ```java
        //값
        List<Pay> pays = Arrays.asList(...);
        
        //로직
        Long naverPaySum = pays.stream().filter(pay -> pay.getPayType().equals(NAVER_PAY)...;
        ```
    - 특정 계산식을 강제할 수 없다.-> ?좀 더 정확히 이해하기
    - 코드의 파편화 확률이 증가한다.
    
        **-> 일급 컬렉션으로 만들어서 묶어버림**

4. 이름이 있는 컬렉션
    - 이름이 없을경우? -> 변수명으로 구분
        - 검색이 어려움 (변수명으로만 검색이 되는데, 개발자마다 변수명을 다르게 지으니까)
        - 명확한 표현이 어려움 (변수명에 불과함)
    
        **-> 일급 컬렉션으로 만들어서 이 컬렉션을 타입으로 해서 컬렉션을 사용**




